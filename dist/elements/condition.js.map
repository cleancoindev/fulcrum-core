{"version":3,"sources":["../../src/elements/condition.js"],"names":[],"mappings":"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","file":"condition.js","sourcesContent":["import TextUtils from '../utils/text-utils';\n\nexport default class Condition {\n  constructor(element, attributes) {\n    this.element = element;\n    this.fieldKey = attributes.field_key;\n    this.operator = attributes.operator;\n    this.value = attributes.value;\n  }\n\n  static isEqual(formValue, stringValue) {\n    if (formValue == null) {\n      return TextUtils.isEmpty(stringValue);\n    }\n    return formValue.isEqual(stringValue);\n  }\n\n  static isEmpty(formValue) {\n    return formValue === null || formValue.isEmpty();\n  }\n\n  static contains(formValue, stringValue) {\n    if (formValue == null) {\n      return TextUtils.isEmpty(stringValue);\n    }\n    return formValue.contains(stringValue);\n  }\n\n  static startsWith(formValue, stringValue) {\n    if (formValue == null) {\n      return TextUtils.isEmpty(stringValue);\n    }\n    return formValue.startsWith(stringValue);\n  }\n\n  static isLessThan(formValue, stringValue) {\n    if (formValue == null) {\n      return TextUtils.isEmpty(stringValue);\n    }\n    return formValue.isLessThan(stringValue);\n  }\n\n  static isGreaterThan(formValue, stringValue) {\n    if (formValue == null) {\n      return TextUtils.isEmpty(stringValue);\n    }\n    return formValue.isGreaterThan(stringValue);\n  }\n\n  static shouldElementBeVisible(element, record, values, cache) {\n    if (cache != null && cache[element.key] != null) {\n      return cache[element.key];\n    }\n\n    cache = cache || {};\n\n    let shouldBeVisible = Condition.shouldElementBeVisibleRecursive(element, record, values, cache);\n\n    if (element.isSectionElement()) {\n      let hasVisibleChildren = false;\n\n      for (let childElement of element.elements) {\n        const visible = Condition.shouldElementBeVisibleRecursive(childElement, record, values, cache);\n\n        if (visible) {\n          hasVisibleChildren = true;\n          break;\n        }\n      }\n\n      shouldBeVisible = shouldBeVisible && hasVisibleChildren;\n    }\n\n    return shouldBeVisible;\n  }\n\n  static shouldElementBeVisibleRecursive(element, record, values, cache) {\n    if (cache != null && cache[element.key] != null) {\n      return cache[element.key];\n    }\n\n    // break circular conditions by assigning an early `true` value so if this\n    // method is re-entered again for the same element before the recursion\n    // ends, it early exits instead of blowing the stack\n    cache[element.key] = true;\n\n    if (element.hidden || element.hasHiddenParent) {\n      cache[element.key] = false;\n      return false;\n    }\n\n    let shouldBeVisible = false;\n\n    if (!element.hasVisibilityConditions) {\n      shouldBeVisible = true;\n    }\n\n    if (element.visibleConditionsType === 'any') {\n      for (let condition of element.visibleConditions) {\n        const isSatisfied = condition.isSatisfied(record, values, cache);\n\n        if (isSatisfied) {\n          shouldBeVisible = true;\n          break;\n        }\n      }\n    } else if (element.visibleConditionsType === 'all') {\n      shouldBeVisible = true;\n\n      for (let condition of element.visibleConditions) {\n        const isSatisfied = condition.isSatisfied(record, values, cache);\n\n        if (!isSatisfied) {\n          shouldBeVisible = false;\n        }\n      }\n    }\n\n    // Make sure all parent elements are also visible according to these same rules.\n    // If a section is hidden because of a rule, all child elements are implicitly hidden\n    // and should return NO from this method. This makes it very easy to determine value relevance\n    // by looking at only the field values without having to worry about Section elements and\n    // dependencies. See clearInvisibleValuesWithConditionValues for usage of this method that\n    // relies on this behavior.\n\n    let parentsVisible = true;\n\n    let iterator = element.parent;\n\n    while (iterator != null) {\n      const parentVisible = Condition.shouldElementBeVisibleRecursive(iterator, record, values, cache);\n\n      if (!parentVisible) {\n        parentsVisible = false;\n        break;\n      }\n\n      iterator = iterator.parent;\n    }\n\n    const result = parentsVisible && shouldBeVisible;\n\n    cache[element.key] = result;\n\n    return result;\n  }\n\n  static shouldElementBeRequired(element, record, values) {\n    if (!element.hasRequiredConditions) {\n      return element.required;\n    }\n\n    const cache = {};\n\n    let shouldBeRequired = false;\n\n    if (element.requiredConditionsType === 'any') {\n      for (let condition of element.requiredConditions) {\n        const isSatisfied = condition.isSatisfied(record, values, cache);\n\n        if (isSatisfied) {\n          shouldBeRequired = true;\n          break;\n        }\n      }\n    } else if (element.requiredConditionsType === 'all') {\n      shouldBeRequired = true;\n\n      for (let condition of element.requiredConditions) {\n        const isSatisfied = condition.isSatisfied(record, values, cache);\n\n        if (!isSatisfied) {\n          shouldBeRequired = false;\n          break;\n        }\n      }\n    }\n\n    return shouldBeRequired;\n  }\n\n  static valueForCondition(condition, values, record) {\n    if (condition.fieldKey === '@status') {\n      return record.statusValue();\n    }\n    return values.getFormValue(condition.fieldKey);\n  }\n\n  static elementForCondition(condition, record) {\n    if (condition.fieldKey === '@status') {\n      return record.statusValue().statusElement;\n    }\n    return record.form.elementsByKey[condition.fieldKey];\n  }\n\n  isSatisfied(record, values, cache) {\n    const referencedElement = Condition.elementForCondition(this, record);\n\n    let isReferencedFieldSatisfied = true;\n\n    if (referencedElement != null) {\n      // If the referenced element or one its parents is explicitly marked as hidden, it's a special\n      // case and the referenced element should always be considered satisfied so that it's possible\n      // to put conditions on explicitly hidden values.\n\n      const skipElement = referencedElement.hidden || referencedElement.hasHiddenParent;\n\n      if (!skipElement) {\n        isReferencedFieldSatisfied = Condition.shouldElementBeVisibleRecursive(referencedElement, record, values, cache);\n      }\n    }\n\n    return this._isSatisfied(record, values, isReferencedFieldSatisfied);\n  }\n\n  _isSatisfied(record, values, isReferencedFieldSatisfied) {\n    let formValue = null;\n\n    // if all of this field's conditions aren't also satisfied, treat the value as nil (empty). This has the same\n    // effect as 'clearing' invisible values by treating them as blank when their conditions aren't met, regardless\n    // of the actual preserved value in the field. If a field is invisible, its value is always nil with respect\n    // to condition logic.\n\n    if (isReferencedFieldSatisfied) {\n      formValue = Condition.valueForCondition(this, values, record);\n    }\n\n    switch (this.operator) {\n      case 'equal_to':\n        return Condition.isEqual(formValue, this.value);\n\n      case 'not_equal_to':\n        return !Condition.isEqual(formValue, this.value);\n\n      case 'is_empty':\n        return Condition.isEmpty(formValue);\n\n      case 'is_not_empty':\n        return !Condition.isEmpty(formValue);\n\n      case 'contains':\n        return Condition.contains(formValue, this.value);\n\n      case 'starts_with':\n        return Condition.startsWith(formValue, this.value);\n\n      case 'greater_than':\n        return Condition.greaterThan(formValue, this.value);\n\n      case 'less_than':\n        return Condition.lessThan(formValue, this.value);\n\n      default:\n        break;\n    }\n\n    return true;\n  }\n}\n"]}