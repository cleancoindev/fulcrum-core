{"version":3,"sources":["../../src/elements/condition.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;IAEqB;AACnB,WADmB,SACnB,CAAY,OAAZ,EAAqB,UAArB,EAAiC;0BADd,WACc;;AAC/B,SAAK,OAAL,GAAe,OAAf,CAD+B;AAE/B,SAAK,QAAL,GAAgB,WAAW,SAAX,CAFe;AAG/B,SAAK,QAAL,GAAgB,WAAW,QAAX,CAHe;AAI/B,SAAK,KAAL,GAAa,WAAW,KAAX,CAJkB;GAAjC;;eADmB;;gCAiMP,QAAQ,QAAQ,OAAO;AACjC,UAAM,oBAAoB,UAAU,mBAAV,CAA8B,IAA9B,EAAoC,MAApC,CAApB,CAD2B;;AAGjC,UAAI,6BAA6B,IAA7B,CAH6B;;AAKjC,UAAI,qBAAqB,IAArB,EAA2B;;;;;AAK7B,YAAM,cAAc,kBAAkB,MAAlB,IAA4B,kBAAkB,eAAlB,CALnB;;AAO7B,YAAI,CAAC,WAAD,EAAc;AAChB,uCAA6B,UAAU,+BAAV,CAA0C,iBAA1C,EAA6D,MAA7D,EAAqE,MAArE,EAA6E,KAA7E,CAA7B,CADgB;SAAlB;OAPF;;AAYA,aAAO,KAAK,YAAL,CAAkB,MAAlB,EAA0B,MAA1B,EAAkC,0BAAlC,CAAP,CAjBiC;;;;iCAoBtB,QAAQ,QAAQ,4BAA4B;AACvD,UAAI,YAAY,IAAZ;;;;;;;AADmD,UAQnD,0BAAJ,EAAgC;AAC9B,oBAAY,UAAU,iBAAV,CAA4B,IAA5B,EAAkC,MAAlC,EAA0C,MAA1C,CAAZ,CAD8B;OAAhC;;AAIA,cAAQ,KAAK,QAAL;AACN,aAAK,UAAL;AACE,iBAAO,UAAU,OAAV,CAAkB,SAAlB,EAA6B,KAAK,KAAL,CAApC,CADF;;AADF,aAIO,cAAL;AACE,iBAAO,CAAC,UAAU,OAAV,CAAkB,SAAlB,EAA6B,KAAK,KAAL,CAA9B,CADT;;AAJF,aAOO,UAAL;AACE,iBAAO,UAAU,OAAV,CAAkB,SAAlB,CAAP,CADF;;AAPF,aAUO,cAAL;AACE,iBAAO,CAAC,UAAU,OAAV,CAAkB,SAAlB,CAAD,CADT;;AAVF,aAaO,UAAL;AACE,iBAAO,UAAU,QAAV,CAAmB,SAAnB,EAA8B,KAAK,KAAL,CAArC,CADF;;AAbF,aAgBO,aAAL;AACE,iBAAO,UAAU,UAAV,CAAqB,SAArB,EAAgC,KAAK,KAAL,CAAvC,CADF;;AAhBF,aAmBO,cAAL;AACE,iBAAO,UAAU,WAAV,CAAsB,SAAtB,EAAiC,KAAK,KAAL,CAAxC,CADF;;AAnBF,aAsBO,WAAL;AACE,iBAAO,UAAU,QAAV,CAAmB,SAAnB,EAA8B,KAAK,KAAL,CAArC,CADF;;AAtBF;AA0BI,gBADF;AAzBF,OAZuD;;AAyCvD,aAAO,IAAP,CAzCuD;;;;4BA7M1C,WAAW,aAAa;AACrC,UAAI,aAAa,IAAb,EAAmB;AACrB,eAAO,oBAAU,OAAV,CAAkB,WAAlB,CAAP,CADqB;OAAvB;AAGA,aAAO,UAAU,OAAV,CAAkB,WAAlB,CAAP,CAJqC;;;;4BAOxB,WAAW;AACxB,aAAO,cAAc,IAAd,IAAsB,UAAU,OAAV,EAAtB,CADiB;;;;6BAIV,WAAW,aAAa;AACtC,UAAI,aAAa,IAAb,EAAmB;AACrB,eAAO,oBAAU,OAAV,CAAkB,WAAlB,CAAP,CADqB;OAAvB;AAGA,aAAO,UAAU,QAAV,CAAmB,WAAnB,CAAP,CAJsC;;;;+BAOtB,WAAW,aAAa;AACxC,UAAI,aAAa,IAAb,EAAmB;AACrB,eAAO,oBAAU,OAAV,CAAkB,WAAlB,CAAP,CADqB;OAAvB;AAGA,aAAO,UAAU,UAAV,CAAqB,WAArB,CAAP,CAJwC;;;;+BAOxB,WAAW,aAAa;AACxC,UAAI,aAAa,IAAb,EAAmB;AACrB,eAAO,oBAAU,OAAV,CAAkB,WAAlB,CAAP,CADqB;OAAvB;AAGA,aAAO,UAAU,UAAV,CAAqB,WAArB,CAAP,CAJwC;;;;kCAOrB,WAAW,aAAa;AAC3C,UAAI,aAAa,IAAb,EAAmB;AACrB,eAAO,oBAAU,OAAV,CAAkB,WAAlB,CAAP,CADqB;OAAvB;AAGA,aAAO,UAAU,aAAV,CAAwB,WAAxB,CAAP,CAJ2C;;;;2CAOf,SAAS,QAAQ,QAAQ,OAAO;AAC5D,UAAI,SAAS,IAAT,IAAiB,MAAM,QAAQ,GAAR,CAAN,IAAsB,IAAtB,EAA4B;AAC/C,eAAO,MAAM,QAAQ,GAAR,CAAb,CAD+C;OAAjD;;AAIA,cAAQ,SAAS,EAAT,CALoD;;AAO5D,UAAI,kBAAkB,UAAU,+BAAV,CAA0C,OAA1C,EAAmD,MAAnD,EAA2D,MAA3D,EAAmE,KAAnE,CAAlB,CAPwD;;AAS5D,UAAI,QAAQ,gBAAR,EAA0B;AAC5B,YAAI,qBAAqB,KAArB,CADwB;;;;;;;AAG5B,+BAAyB,QAAQ,QAAR,0BAAzB,oGAA2C;gBAAlC,2BAAkC;;AACzC,gBAAM,UAAU,UAAU,+BAAV,CAA0C,YAA1C,EAAwD,MAAxD,EAAgE,MAAhE,EAAwE,KAAxE,CAAV,CADmC;;AAGzC,gBAAI,OAAJ,EAAa;AACX,mCAAqB,IAArB,CADW;AAEX,oBAFW;aAAb;WAHF;;;;;;;;;;;;;;SAH4B;;AAY5B,0BAAkB,mBAAmB,kBAAnB,CAZU;OAA9B;;AAeA,aAAO,eAAP,CAxB4D;;;;oDA2BvB,SAAS,QAAQ,QAAQ,OAAO;AACrE,UAAI,SAAS,IAAT,IAAiB,MAAM,QAAQ,GAAR,CAAN,IAAsB,IAAtB,EAA4B;AAC/C,eAAO,MAAM,QAAQ,GAAR,CAAb,CAD+C;OAAjD;;;;;AADqE,WAQrE,CAAM,QAAQ,GAAR,CAAN,GAAqB,IAArB,CARqE;;AAUrE,UAAI,QAAQ,MAAR,IAAkB,QAAQ,eAAR,EAAyB;AAC7C,cAAM,QAAQ,GAAR,CAAN,GAAqB,KAArB,CAD6C;AAE7C,eAAO,KAAP,CAF6C;OAA/C;;AAKA,UAAI,kBAAkB,KAAlB,CAfiE;;AAiBrE,UAAI,CAAC,QAAQ,uBAAR,EAAiC;AACpC,0BAAkB,IAAlB,CADoC;OAAtC;;AAIA,UAAI,QAAQ,qBAAR,KAAkC,KAAlC,EAAyC;;;;;;AAC3C,gCAAsB,QAAQ,iBAAR,2BAAtB,wGAAiD;gBAAxC,yBAAwC;;AAC/C,gBAAM,cAAc,UAAU,WAAV,CAAsB,MAAtB,EAA8B,MAA9B,EAAsC,KAAtC,CAAd,CADyC;;AAG/C,gBAAI,WAAJ,EAAiB;AACf,gCAAkB,IAAlB,CADe;AAEf,oBAFe;aAAjB;WAHF;;;;;;;;;;;;;;SAD2C;OAA7C,MASO,IAAI,QAAQ,qBAAR,KAAkC,KAAlC,EAAyC;AAClD,0BAAkB,IAAlB,CADkD;;;;;;;AAGlD,gCAAsB,QAAQ,iBAAR,2BAAtB,wGAAiD;gBAAxC,yBAAwC;;AAC/C,gBAAM,cAAc,UAAU,WAAV,CAAsB,MAAtB,EAA8B,MAA9B,EAAsC,KAAtC,CAAd,CADyC;;AAG/C,gBAAI,CAAC,WAAD,EAAc;AAChB,gCAAkB,KAAlB,CADgB;aAAlB;WAHF;;;;;;;;;;;;;;SAHkD;OAA7C;;;;;;;;;AA9B8D,UAiDjE,iBAAiB,IAAjB,CAjDiE;;AAmDrE,UAAI,WAAW,QAAQ,MAAR,CAnDsD;;AAqDrE,aAAO,YAAY,IAAZ,EAAkB;AACvB,YAAM,gBAAgB,UAAU,+BAAV,CAA0C,QAA1C,EAAoD,MAApD,EAA4D,MAA5D,EAAoE,KAApE,CAAhB,CADiB;;AAGvB,YAAI,CAAC,aAAD,EAAgB;AAClB,2BAAiB,KAAjB,CADkB;AAElB,gBAFkB;SAApB;;AAKA,mBAAW,SAAS,MAAT,CARY;OAAzB;;AAWA,UAAM,SAAS,kBAAkB,eAAlB,CAhEsD;;AAkErE,YAAM,QAAQ,GAAR,CAAN,GAAqB,MAArB,CAlEqE;;AAoErE,aAAO,MAAP,CApEqE;;;;4CAuExC,SAAS,QAAQ,QAAQ;AACtD,UAAI,CAAC,QAAQ,qBAAR,EAA+B;AAClC,eAAO,QAAQ,QAAR,CAD2B;OAApC;;AAIA,UAAM,QAAQ,EAAR,CALgD;;AAOtD,UAAI,mBAAmB,KAAnB,CAPkD;;AAStD,UAAI,QAAQ,sBAAR,KAAmC,KAAnC,EAA0C;;;;;;AAC5C,gCAAsB,QAAQ,kBAAR,2BAAtB,wGAAkD;gBAAzC,yBAAyC;;AAChD,gBAAM,cAAc,UAAU,WAAV,CAAsB,MAAtB,EAA8B,MAA9B,EAAsC,KAAtC,CAAd,CAD0C;;AAGhD,gBAAI,WAAJ,EAAiB;AACf,iCAAmB,IAAnB,CADe;AAEf,oBAFe;aAAjB;WAHF;;;;;;;;;;;;;;SAD4C;OAA9C,MASO,IAAI,QAAQ,sBAAR,KAAmC,KAAnC,EAA0C;AACnD,2BAAmB,IAAnB,CADmD;;;;;;;AAGnD,gCAAsB,QAAQ,kBAAR,2BAAtB,wGAAkD;gBAAzC,yBAAyC;;AAChD,gBAAM,cAAc,UAAU,WAAV,CAAsB,MAAtB,EAA8B,MAA9B,EAAsC,KAAtC,CAAd,CAD0C;;AAGhD,gBAAI,CAAC,WAAD,EAAc;AAChB,iCAAmB,KAAnB,CADgB;AAEhB,oBAFgB;aAAlB;WAHF;;;;;;;;;;;;;;SAHmD;OAA9C;;AAaP,aAAO,gBAAP,CA/BsD;;;;sCAkC/B,WAAW,QAAQ,QAAQ;AAClD,UAAI,UAAU,QAAV,KAAuB,SAAvB,EAAkC;AACpC,eAAO,OAAO,WAAP,EAAP,CADoC;OAAtC;AAGA,aAAO,OAAO,GAAP,CAAW,UAAU,QAAV,CAAlB,CAJkD;;;;wCAOzB,WAAW,QAAQ;AAC5C,UAAI,UAAU,QAAV,KAAuB,SAAvB,EAAkC;AACpC,eAAO,OAAO,WAAP,GAAqB,aAArB,CAD6B;OAAtC;AAGA,aAAO,OAAO,IAAP,CAAY,aAAZ,CAA0B,UAAU,QAAV,CAAjC,CAJ4C;;;;SA1L3B","file":"condition.js","sourcesContent":["import TextUtils from '../utils/text-utils';\n\nexport default class Condition {\n  constructor(element, attributes) {\n    this.element = element;\n    this.fieldKey = attributes.field_key;\n    this.operator = attributes.operator;\n    this.value = attributes.value;\n  }\n\n  static isEqual(formValue, stringValue) {\n    if (formValue == null) {\n      return TextUtils.isEmpty(stringValue);\n    }\n    return formValue.isEqual(stringValue);\n  }\n\n  static isEmpty(formValue) {\n    return formValue === null || formValue.isEmpty();\n  }\n\n  static contains(formValue, stringValue) {\n    if (formValue == null) {\n      return TextUtils.isEmpty(stringValue);\n    }\n    return formValue.contains(stringValue);\n  }\n\n  static startsWith(formValue, stringValue) {\n    if (formValue == null) {\n      return TextUtils.isEmpty(stringValue);\n    }\n    return formValue.startsWith(stringValue);\n  }\n\n  static isLessThan(formValue, stringValue) {\n    if (formValue == null) {\n      return TextUtils.isEmpty(stringValue);\n    }\n    return formValue.isLessThan(stringValue);\n  }\n\n  static isGreaterThan(formValue, stringValue) {\n    if (formValue == null) {\n      return TextUtils.isEmpty(stringValue);\n    }\n    return formValue.isGreaterThan(stringValue);\n  }\n\n  static shouldElementBeVisible(element, record, values, cache) {\n    if (cache != null && cache[element.key] != null) {\n      return cache[element.key];\n    }\n\n    cache = cache || {};\n\n    let shouldBeVisible = Condition.shouldElementBeVisibleRecursive(element, record, values, cache);\n\n    if (element.isSectionElement) {\n      let hasVisibleChildren = false;\n\n      for (let childElement of element.elements) {\n        const visible = Condition.shouldElementBeVisibleRecursive(childElement, record, values, cache);\n\n        if (visible) {\n          hasVisibleChildren = true;\n          break;\n        }\n      }\n\n      shouldBeVisible = shouldBeVisible && hasVisibleChildren;\n    }\n\n    return shouldBeVisible;\n  }\n\n  static shouldElementBeVisibleRecursive(element, record, values, cache) {\n    if (cache != null && cache[element.key] != null) {\n      return cache[element.key];\n    }\n\n    // break circular conditions by assigning an early `true` value so if this\n    // method is re-entered again for the same element before the recursion\n    // ends, it early exits instead of blowing the stack\n    cache[element.key] = true;\n\n    if (element.hidden || element.hasHiddenParent) {\n      cache[element.key] = false;\n      return false;\n    }\n\n    let shouldBeVisible = false;\n\n    if (!element.hasVisibilityConditions) {\n      shouldBeVisible = true;\n    }\n\n    if (element.visibleConditionsType === 'any') {\n      for (let condition of element.visibleConditions) {\n        const isSatisfied = condition.isSatisfied(record, values, cache);\n\n        if (isSatisfied) {\n          shouldBeVisible = true;\n          break;\n        }\n      }\n    } else if (element.visibleConditionsType === 'all') {\n      shouldBeVisible = true;\n\n      for (let condition of element.visibleConditions) {\n        const isSatisfied = condition.isSatisfied(record, values, cache);\n\n        if (!isSatisfied) {\n          shouldBeVisible = false;\n        }\n      }\n    }\n\n    // Make sure all parent elements are also visible according to these same rules.\n    // If a section is hidden because of a rule, all child elements are implicitly hidden\n    // and should return NO from this method. This makes it very easy to determine value relevance\n    // by looking at only the field values without having to worry about Section elements and\n    // dependencies. See clearInvisibleValuesWithConditionValues for usage of this method that\n    // relies on this behavior.\n\n    let parentsVisible = true;\n\n    let iterator = element.parent;\n\n    while (iterator != null) {\n      const parentVisible = Condition.shouldElementBeVisibleRecursive(iterator, record, values, cache);\n\n      if (!parentVisible) {\n        parentsVisible = false;\n        break;\n      }\n\n      iterator = iterator.parent;\n    }\n\n    const result = parentsVisible && shouldBeVisible;\n\n    cache[element.key] = result;\n\n    return result;\n  }\n\n  static shouldElementBeRequired(element, record, values) {\n    if (!element.hasRequiredConditions) {\n      return element.required;\n    }\n\n    const cache = {};\n\n    let shouldBeRequired = false;\n\n    if (element.requiredConditionsType === 'any') {\n      for (let condition of element.requiredConditions) {\n        const isSatisfied = condition.isSatisfied(record, values, cache);\n\n        if (isSatisfied) {\n          shouldBeRequired = true;\n          break;\n        }\n      }\n    } else if (element.requiredConditionsType === 'all') {\n      shouldBeRequired = true;\n\n      for (let condition of element.requiredConditions) {\n        const isSatisfied = condition.isSatisfied(record, values, cache);\n\n        if (!isSatisfied) {\n          shouldBeRequired = false;\n          break;\n        }\n      }\n    }\n\n    return shouldBeRequired;\n  }\n\n  static valueForCondition(condition, values, record) {\n    if (condition.fieldKey === '@status') {\n      return record.statusValue();\n    }\n    return values.get(condition.fieldKey);\n  }\n\n  static elementForCondition(condition, record) {\n    if (condition.fieldKey === '@status') {\n      return record.statusValue().statusElement;\n    }\n    return record.form.elementsByKey[condition.fieldKey];\n  }\n\n  isSatisfied(record, values, cache) {\n    const referencedElement = Condition.elementForCondition(this, record);\n\n    let isReferencedFieldSatisfied = true;\n\n    if (referencedElement != null) {\n      // If the referenced element or one its parents is explicitly marked as hidden, it's a special\n      // case and the referenced element should always be considered satisfied so that it's possible\n      // to put conditions on explicitly hidden values.\n\n      const skipElement = referencedElement.hidden || referencedElement.hasHiddenParent;\n\n      if (!skipElement) {\n        isReferencedFieldSatisfied = Condition.shouldElementBeVisibleRecursive(referencedElement, record, values, cache);\n      }\n    }\n\n    return this._isSatisfied(record, values, isReferencedFieldSatisfied);\n  }\n\n  _isSatisfied(record, values, isReferencedFieldSatisfied) {\n    let formValue = null;\n\n    // if all of this field's conditions aren't also satisfied, treat the value as nil (empty). This has the same\n    // effect as 'clearing' invisible values by treating them as blank when their conditions aren't met, regardless\n    // of the actual preserved value in the field. If a field is invisible, its value is always nil with respect\n    // to condition logic.\n\n    if (isReferencedFieldSatisfied) {\n      formValue = Condition.valueForCondition(this, values, record);\n    }\n\n    switch (this.operator) {\n      case 'equal_to':\n        return Condition.isEqual(formValue, this.value);\n\n      case 'not_equal_to':\n        return !Condition.isEqual(formValue, this.value);\n\n      case 'is_empty':\n        return Condition.isEmpty(formValue);\n\n      case 'is_not_empty':\n        return !Condition.isEmpty(formValue);\n\n      case 'contains':\n        return Condition.contains(formValue, this.value);\n\n      case 'starts_with':\n        return Condition.startsWith(formValue, this.value);\n\n      case 'greater_than':\n        return Condition.greaterThan(formValue, this.value);\n\n      case 'less_than':\n        return Condition.lessThan(formValue, this.value);\n\n      default:\n        break;\n    }\n\n    return true;\n  }\n}\n"]}