{"version":3,"sources":["../../src/elements/condition.js"],"names":[],"mappings":"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","file":"condition.js","sourcesContent":["import TextUtils from '../utils/text-utils';\n\nexport default class Condition {\n  constructor(element, attributes) {\n    this.element = element;\n    this.fieldKey = attributes.field_key;\n    this.operator = attributes.operator;\n    this.value = attributes.value;\n  }\n\n  static isEqual(formValue, stringValue) {\n    if (formValue == null) {\n      return TextUtils.isEmpty(stringValue);\n    }\n    return formValue.isEqual(stringValue);\n  }\n\n  static isEmpty(formValue) {\n    return formValue === null || formValue.isEmpty();\n  }\n\n  static contains(formValue, stringValue) {\n    if (formValue == null) {\n      return TextUtils.isEmpty(stringValue);\n    }\n    return formValue.contains(stringValue);\n  }\n\n  static startsWith(formValue, stringValue) {\n    if (formValue == null) {\n      return TextUtils.isEmpty(stringValue);\n    }\n    return formValue.startsWith(stringValue);\n  }\n\n  static isLessThan(formValue, stringValue) {\n    if (formValue == null) {\n      return TextUtils.isEmpty(stringValue);\n    }\n    return formValue.isLessThan(stringValue);\n  }\n\n  static isGreaterThan(formValue, stringValue) {\n    if (formValue == null) {\n      return TextUtils.isEmpty(stringValue);\n    }\n    return formValue.isGreaterThan(stringValue);\n  }\n\n  static shouldElementBeVisible(element, record, values, cache) {\n    if (cache != null && cache[element.key] != null) {\n      return cache[element.key];\n    }\n\n    cache = cache || {};\n\n    let shouldBeVisible = Condition.shouldElementBeVisibleRecursive(element, record, values, cache);\n\n    if (element.isSectionElement) {\n      let hasVisibleChildren = false;\n\n      for (let childElement of element.elements) {\n        const visible = Condition.shouldElementBeVisibleRecursive(childElement, record, values, cache);\n\n        if (visible) {\n          hasVisibleChildren = true;\n          break;\n        }\n      }\n\n      shouldBeVisible = shouldBeVisible && hasVisibleChildren;\n    }\n\n    return shouldBeVisible;\n  }\n\n  static shouldElementBeVisibleRecursive(element, record, values, cache) {\n    if (cache != null && cache[element.key] != null) {\n      return cache[element.key];\n    }\n\n    // break circular conditions by assigning an early `true` value so if this\n    // method is re-entered again for the same element before the recursion\n    // ends, it early exits instead of blowing the stack\n    cache[element.key] = true;\n\n    if (element.hidden || element.hasHiddenParent) {\n      cache[element.key] = false;\n      return false;\n    }\n\n    let shouldBeVisible = false;\n\n    if (!element.hasVisibilityConditions) {\n      shouldBeVisible = true;\n    }\n\n    if (element.visibleConditionsType === 'any') {\n      for (let condition of element.visibleConditions) {\n        const isSatisfied = condition.isSatisfied(record, values, cache);\n\n        if (isSatisfied) {\n          shouldBeVisible = true;\n          break;\n        }\n      }\n    } else if (element.visibleConditionsType === 'all') {\n      shouldBeVisible = true;\n\n      for (let condition of element.visibleConditions) {\n        const isSatisfied = condition.isSatisfied(record, values, cache);\n\n        if (!isSatisfied) {\n          shouldBeVisible = false;\n        }\n      }\n    }\n\n    // Make sure all parent elements are also visible according to these same rules.\n    // If a section is hidden because of a rule, all child elements are implicitly hidden\n    // and should return NO from this method. This makes it very easy to determine value relevance\n    // by looking at only the field values without having to worry about Section elements and\n    // dependencies. See clearInvisibleValuesWithConditionValues for usage of this method that\n    // relies on this behavior.\n\n    let parentsVisible = true;\n\n    let iterator = element.parent;\n\n    while (iterator != null) {\n      const parentVisible = Condition.shouldElementBeVisibleRecursive(iterator, record, values, cache);\n\n      if (!parentVisible) {\n        parentsVisible = false;\n        break;\n      }\n\n      iterator = iterator.parent;\n    }\n\n    const result = parentsVisible && shouldBeVisible;\n\n    cache[element.key] = result;\n\n    return result;\n  }\n\n  static shouldElementBeRequired(element, record, values) {\n    if (!element.hasRequiredConditions) {\n      return element.required;\n    }\n\n    const cache = {};\n\n    let shouldBeRequired = false;\n\n    if (element.requiredConditionsType === 'any') {\n      for (let condition of element.requiredConditions) {\n        const isSatisfied = condition.isSatisfied(record, values, cache);\n\n        if (isSatisfied) {\n          shouldBeRequired = true;\n          break;\n        }\n      }\n    } else if (element.requiredConditionsType === 'all') {\n      shouldBeRequired = true;\n\n      for (let condition of element.requiredConditions) {\n        const isSatisfied = condition.isSatisfied(record, values, cache);\n\n        if (!isSatisfied) {\n          shouldBeRequired = false;\n          break;\n        }\n      }\n    }\n\n    return shouldBeRequired;\n  }\n\n  static valueForCondition(condition, values, record) {\n    if (condition.fieldKey === '@status') {\n      return record.statusValue();\n    }\n    return values.get(condition.fieldKey);\n  }\n\n  static elementForCondition(condition, record) {\n    if (condition.fieldKey === '@status') {\n      return record.statusValue().statusElement;\n    }\n    return record.form.elementsByKey[condition.fieldKey];\n  }\n\n  isSatisfied(record, values, cache) {\n    const referencedElement = Condition.elementForCondition(this, record);\n\n    let isReferencedFieldSatisfied = true;\n\n    if (referencedElement != null) {\n      // If the referenced element or one its parents is explicitly marked as hidden, it's a special\n      // case and the referenced element should always be considered satisfied so that it's possible\n      // to put conditions on explicitly hidden values.\n\n      const skipElement = referencedElement.hidden || referencedElement.hasHiddenParent;\n\n      if (!skipElement) {\n        isReferencedFieldSatisfied = Condition.shouldElementBeVisibleRecursive(referencedElement, record, values, cache);\n      }\n    }\n\n    return this._isSatisfied(record, values, isReferencedFieldSatisfied);\n  }\n\n  _isSatisfied(record, values, isReferencedFieldSatisfied) {\n    let formValue = null;\n\n    // if all of this field's conditions aren't also satisfied, treat the value as nil (empty). This has the same\n    // effect as 'clearing' invisible values by treating them as blank when their conditions aren't met, regardless\n    // of the actual preserved value in the field. If a field is invisible, its value is always nil with respect\n    // to condition logic.\n\n    if (isReferencedFieldSatisfied) {\n      formValue = Condition.valueForCondition(this, values, record);\n    }\n\n    switch (this.operator) {\n      case 'equal_to':\n        return Condition.isEqual(formValue, this.value);\n\n      case 'not_equal_to':\n        return !Condition.isEqual(formValue, this.value);\n\n      case 'is_empty':\n        return Condition.isEmpty(formValue);\n\n      case 'is_not_empty':\n        return !Condition.isEmpty(formValue);\n\n      case 'contains':\n        return Condition.contains(formValue, this.value);\n\n      case 'starts_with':\n        return Condition.startsWith(formValue, this.value);\n\n      case 'greater_than':\n        return Condition.greaterThan(formValue, this.value);\n\n      case 'less_than':\n        return Condition.lessThan(formValue, this.value);\n\n      default:\n        break;\n    }\n\n    return true;\n  }\n}\n"]}