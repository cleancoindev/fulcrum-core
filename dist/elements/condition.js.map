{"version":3,"sources":["../../src/elements/condition.js"],"names":["Condition","element","attributes","fieldKey","field_key","operator","value","isEqual","formValue","stringValue","isEmpty","contains","startsWith","isLessThan","isGreaterThan","shouldElementBeVisible","record","values","visibilityCache","key","cache","shouldBeVisible","shouldElementBeVisibleRecursive","isSectionElement","hasVisibleChildren","elements","childElement","visible","isHidden","hasHiddenParent","hasVisibilityConditions","visibleConditionsType","visibleConditions","condition","isSatisfied","parentsVisible","iterator","parent","parentVisible","result","shouldElementBeRequired","hasRequiredConditions","isRequired","shouldBeRequired","requiredConditionsType","requiredConditions","valueForCondition","statusValue","get","elementForCondition","form","elementsByKey","referencedElement","isReferencedFieldSatisfied","skipElement","_isSatisfied"],"mappings":";;;;AAAA;;;;;;;;IAEqBA,S;AACnB,qBAAYC,OAAZ,EAAqBC,UAArB,EAAiC;AAAA;;AAC/B,SAAKD,OAAL,GAAeA,OAAf;AACA,SAAKE,QAAL,GAAgBD,WAAWE,SAA3B;AACA,SAAKC,QAAL,GAAgBH,WAAWG,QAA3B;AACA,SAAKC,KAAL,GAAaJ,WAAWI,KAAxB;AACD;;YAEMC,O,oBAAQC,S,EAAWC,W,EAAa;AACrC,QAAID,aAAa,IAAjB,EAAuB;AACrB,aAAO,oBAAUE,OAAV,CAAkBD,WAAlB,CAAP;AACD;AACD,WAAOD,UAAUD,OAAV,CAAkBE,WAAlB,CAAP;AACD,G;;YAEMC,O,oBAAQF,S,EAAW;AACxB,WAAOA,aAAa,IAAb,IAAqBA,UAAUE,OAAtC;AACD,G;;YAEMC,Q,qBAASH,S,EAAWC,W,EAAa;AACtC,QAAID,aAAa,IAAjB,EAAuB;AACrB,aAAO,oBAAUE,OAAV,CAAkBD,WAAlB,CAAP;AACD;AACD,WAAOD,UAAUG,QAAV,CAAmBF,WAAnB,CAAP;AACD,G;;YAEMG,U,uBAAWJ,S,EAAWC,W,EAAa;AACxC,QAAID,aAAa,IAAjB,EAAuB;AACrB,aAAO,oBAAUE,OAAV,CAAkBD,WAAlB,CAAP;AACD;AACD,WAAOD,UAAUI,UAAV,CAAqBH,WAArB,CAAP;AACD,G;;YAEMI,U,uBAAWL,S,EAAWC,W,EAAa;AACxC,QAAID,aAAa,IAAjB,EAAuB;AACrB,aAAO,oBAAUE,OAAV,CAAkBD,WAAlB,CAAP;AACD;AACD,WAAOD,UAAUK,UAAV,CAAqBJ,WAArB,CAAP;AACD,G;;YAEMK,a,0BAAcN,S,EAAWC,W,EAAa;AAC3C,QAAID,aAAa,IAAjB,EAAuB;AACrB,aAAO,oBAAUE,OAAV,CAAkBD,WAAlB,CAAP;AACD;AACD,WAAOD,UAAUM,aAAV,CAAwBL,WAAxB,CAAP;AACD,G;;YAEMM,sB,mCAAuBd,O,EAASe,M,EAAQC,M,EAAQC,e,EAAiB;AACtE,QAAIA,mBAAmB,IAAnB,IAA2BA,gBAAgBjB,QAAQkB,GAAxB,KAAgC,IAA/D,EAAqE;AACnE,aAAOD,gBAAgBjB,QAAQkB,GAAxB,CAAP;AACD;;AAED,QAAMC,QAAQF,mBAAmB,EAAjC;;AAEA,QAAIG,kBAAkBrB,UAAUsB,+BAAV,CAA0CrB,OAA1C,EAAmDe,MAAnD,EAA2DC,MAA3D,EAAmEG,KAAnE,CAAtB;;AAEA,QAAInB,QAAQsB,gBAAZ,EAA8B;AAC5B,UAAIC,qBAAqB,KAAzB;;AAEA,2BAA2BvB,QAAQwB,QAAnC,kHAA6C;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,YAAlCC,YAAkC;;AAC3C,YAAMC,UAAU3B,UAAUsB,+BAAV,CAA0CI,YAA1C,EAAwDV,MAAxD,EAAgEC,MAAhE,EAAwEG,KAAxE,CAAhB;;AAEA,YAAIO,OAAJ,EAAa;AACXH,+BAAqB,IAArB;AACA;AACD;AACF;;AAEDH,wBAAkBA,mBAAmBG,kBAArC;AACD;;AAED,WAAOH,eAAP;AACD,G;;YAEMC,+B,4CAAgCrB,O,EAASe,M,EAAQC,M,EAAQG,K,EAAO;AACrE,QAAIA,SAAS,IAAT,IAAiBA,MAAMnB,QAAQkB,GAAd,KAAsB,IAA3C,EAAiD;AAC/C,aAAOC,MAAMnB,QAAQkB,GAAd,CAAP;AACD;;AAED;AACA;AACA;AACAC,UAAMnB,QAAQkB,GAAd,IAAqB,IAArB;;AAEA,QAAIlB,QAAQ2B,QAAR,IAAoB3B,QAAQ4B,eAAhC,EAAiD;AAC/CT,YAAMnB,QAAQkB,GAAd,IAAqB,KAArB;AACA,aAAO,KAAP;AACD;;AAED,QAAIE,kBAAkB,KAAtB;;AAEA,QAAI,CAACpB,QAAQ6B,uBAAb,EAAsC;AACpCT,wBAAkB,IAAlB;AACD;;AAED,QAAIpB,QAAQ8B,qBAAR,KAAkC,KAAtC,EAA6C;AAC3C,4BAAwB9B,QAAQ+B,iBAAhC,yHAAmD;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,YAAxCC,SAAwC;;AACjD,YAAMC,cAAcD,UAAUC,WAAV,CAAsBlB,MAAtB,EAA8BC,MAA9B,EAAsCG,KAAtC,CAApB;;AAEA,YAAIc,WAAJ,EAAiB;AACfb,4BAAkB,IAAlB;AACA;AACD;AACF;AACF,KATD,MASO,IAAIpB,QAAQ8B,qBAAR,KAAkC,KAAtC,EAA6C;AAClDV,wBAAkB,IAAlB;;AAEA,4BAAwBpB,QAAQ+B,iBAAhC,yHAAmD;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,YAAxCC,UAAwC;;AACjD,YAAMC,gBAAcD,WAAUC,WAAV,CAAsBlB,MAAtB,EAA8BC,MAA9B,EAAsCG,KAAtC,CAApB;;AAEA,YAAI,CAACc,aAAL,EAAkB;AAChBb,4BAAkB,KAAlB;AACD;AACF;AACF;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAIc,iBAAiB,IAArB;;AAEA,QAAIC,WAAWnC,QAAQoC,MAAvB;;AAEA,WAAOD,YAAY,IAAnB,EAAyB;AACvB,UAAME,gBAAgBtC,UAAUsB,+BAAV,CAA0Cc,QAA1C,EAAoDpB,MAApD,EAA4DC,MAA5D,EAAoEG,KAApE,CAAtB;;AAEA,UAAI,CAACkB,aAAL,EAAoB;AAClBH,yBAAiB,KAAjB;AACA;AACD;;AAEDC,iBAAWA,SAASC,MAApB;AACD;;AAED,QAAME,SAASJ,kBAAkBd,eAAjC;;AAEAD,UAAMnB,QAAQkB,GAAd,IAAqBoB,MAArB;;AAEA,WAAOA,MAAP;AACD,G;;YAEMC,uB,oCAAwBvC,O,EAASe,M,EAAQC,M,EAAQ;AACtD,QAAI,CAAChB,QAAQwC,qBAAb,EAAoC;AAClC,aAAOxC,QAAQyC,UAAf;AACD;;AAED,QAAMtB,QAAQ,EAAd;;AAEA,QAAIuB,mBAAmB,KAAvB;;AAEA,QAAI1C,QAAQ2C,sBAAR,KAAmC,KAAvC,EAA8C;AAC5C,4BAAwB3C,QAAQ4C,kBAAhC,yHAAoD;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,YAAzCZ,SAAyC;;AAClD,YAAMC,cAAcD,UAAUC,WAAV,CAAsBlB,MAAtB,EAA8BC,MAA9B,EAAsCG,KAAtC,CAApB;;AAEA,YAAIc,WAAJ,EAAiB;AACfS,6BAAmB,IAAnB;AACA;AACD;AACF;AACF,KATD,MASO,IAAI1C,QAAQ2C,sBAAR,KAAmC,KAAvC,EAA8C;AACnDD,yBAAmB,IAAnB;;AAEA,4BAAwB1C,QAAQ4C,kBAAhC,yHAAoD;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,YAAzCZ,WAAyC;;AAClD,YAAMC,gBAAcD,YAAUC,WAAV,CAAsBlB,MAAtB,EAA8BC,MAA9B,EAAsCG,KAAtC,CAApB;;AAEA,YAAI,CAACc,aAAL,EAAkB;AAChBS,6BAAmB,KAAnB;AACA;AACD;AACF;AACF;;AAED,WAAOA,gBAAP;AACD,G;;YAEMG,iB,8BAAkBb,S,EAAWhB,M,EAAQD,M,EAAQ;AAClD,QAAIiB,UAAU9B,QAAV,KAAuB,SAA3B,EAAsC;AACpC,aAAOa,OAAO+B,WAAd;AACD;AACD,WAAO9B,OAAO+B,GAAP,CAAWf,UAAU9B,QAArB,CAAP;AACD,G;;YAEM8C,mB,gCAAoBhB,S,EAAWjB,M,EAAQ;AAC5C,QAAIiB,UAAU9B,QAAV,KAAuB,SAA3B,EAAsC;AACpC,aAAOa,OAAO+B,WAAP,CAAmB9C,OAA1B;AACD;AACD,WAAOe,OAAOkC,IAAP,CAAYC,aAAZ,CAA0BlB,UAAU9B,QAApC,CAAP;AACD,G;;sBAED+B,W,wBAAYlB,M,EAAQC,M,EAAQG,K,EAAO;AACjC,QAAMgC,oBAAoBpD,UAAUiD,mBAAV,CAA8B,IAA9B,EAAoCjC,MAApC,CAA1B;;AAEA,QAAIqC,6BAA6B,IAAjC;;AAEA,QAAID,qBAAqB,IAAzB,EAA+B;AAC7B;AACA;AACA;;AAEA,UAAME,cAAcF,kBAAkBxB,QAAlB,IAA8BwB,kBAAkBvB,eAApE;;AAEA,UAAI,CAACyB,WAAL,EAAkB;AAChBD,qCAA6BrD,UAAUsB,+BAAV,CAA0C8B,iBAA1C,EAA6DpC,MAA7D,EAAqEC,MAArE,EAA6EG,KAA7E,CAA7B;AACD;AACF;;AAED,WAAO,KAAKmC,YAAL,CAAkBvC,MAAlB,EAA0BC,MAA1B,EAAkCoC,0BAAlC,CAAP;AACD,G;;sBAEDE,Y,yBAAavC,M,EAAQC,M,EAAQoC,0B,EAA4B;AACvD,QAAI7C,YAAY,IAAhB;;AAEA;AACA;AACA;AACA;;AAEA,QAAI6C,0BAAJ,EAAgC;AAC9B7C,kBAAYR,UAAU8C,iBAAV,CAA4B,IAA5B,EAAkC7B,MAAlC,EAA0CD,MAA1C,CAAZ;AACD;;AAED,YAAQ,KAAKX,QAAb;AACE,WAAK,UAAL;AACE,eAAOL,UAAUO,OAAV,CAAkBC,SAAlB,EAA6B,KAAKF,KAAlC,CAAP;;AAEF,WAAK,cAAL;AACE,eAAO,CAACN,UAAUO,OAAV,CAAkBC,SAAlB,EAA6B,KAAKF,KAAlC,CAAR;;AAEF,WAAK,UAAL;AACE,eAAON,UAAUU,OAAV,CAAkBF,SAAlB,CAAP;;AAEF,WAAK,cAAL;AACE,eAAO,CAACR,UAAUU,OAAV,CAAkBF,SAAlB,CAAR;;AAEF,WAAK,UAAL;AACE,eAAOR,UAAUW,QAAV,CAAmBH,SAAnB,EAA8B,KAAKF,KAAnC,CAAP;;AAEF,WAAK,aAAL;AACE,eAAON,UAAUY,UAAV,CAAqBJ,SAArB,EAAgC,KAAKF,KAArC,CAAP;;AAEF,WAAK,cAAL;AACE,eAAON,UAAUc,aAAV,CAAwBN,SAAxB,EAAmC,KAAKF,KAAxC,CAAP;;AAEF,WAAK,WAAL;AACE,eAAON,UAAUa,UAAV,CAAqBL,SAArB,EAAgC,KAAKF,KAArC,CAAP;;AAEF;AACE;AA1BJ;;AA6BA,WAAO,IAAP;AACD,G;;;;;kBA/PkBN,S","file":"condition.js","sourcesContent":["import TextUtils from '../utils/text-utils';\n\nexport default class Condition {\n  constructor(element, attributes) {\n    this.element = element;\n    this.fieldKey = attributes.field_key;\n    this.operator = attributes.operator;\n    this.value = attributes.value;\n  }\n\n  static isEqual(formValue, stringValue) {\n    if (formValue == null) {\n      return TextUtils.isEmpty(stringValue);\n    }\n    return formValue.isEqual(stringValue);\n  }\n\n  static isEmpty(formValue) {\n    return formValue == null || formValue.isEmpty;\n  }\n\n  static contains(formValue, stringValue) {\n    if (formValue == null) {\n      return TextUtils.isEmpty(stringValue);\n    }\n    return formValue.contains(stringValue);\n  }\n\n  static startsWith(formValue, stringValue) {\n    if (formValue == null) {\n      return TextUtils.isEmpty(stringValue);\n    }\n    return formValue.startsWith(stringValue);\n  }\n\n  static isLessThan(formValue, stringValue) {\n    if (formValue == null) {\n      return TextUtils.isEmpty(stringValue);\n    }\n    return formValue.isLessThan(stringValue);\n  }\n\n  static isGreaterThan(formValue, stringValue) {\n    if (formValue == null) {\n      return TextUtils.isEmpty(stringValue);\n    }\n    return formValue.isGreaterThan(stringValue);\n  }\n\n  static shouldElementBeVisible(element, record, values, visibilityCache) {\n    if (visibilityCache != null && visibilityCache[element.key] != null) {\n      return visibilityCache[element.key];\n    }\n\n    const cache = visibilityCache || {};\n\n    let shouldBeVisible = Condition.shouldElementBeVisibleRecursive(element, record, values, cache);\n\n    if (element.isSectionElement) {\n      let hasVisibleChildren = false;\n\n      for (const childElement of element.elements) {\n        const visible = Condition.shouldElementBeVisibleRecursive(childElement, record, values, cache);\n\n        if (visible) {\n          hasVisibleChildren = true;\n          break;\n        }\n      }\n\n      shouldBeVisible = shouldBeVisible && hasVisibleChildren;\n    }\n\n    return shouldBeVisible;\n  }\n\n  static shouldElementBeVisibleRecursive(element, record, values, cache) {\n    if (cache != null && cache[element.key] != null) {\n      return cache[element.key];\n    }\n\n    // break circular conditions by assigning an early `true` value so if this\n    // method is re-entered again for the same element before the recursion\n    // ends, it early exits instead of blowing the stack\n    cache[element.key] = true;\n\n    if (element.isHidden || element.hasHiddenParent) {\n      cache[element.key] = false;\n      return false;\n    }\n\n    let shouldBeVisible = false;\n\n    if (!element.hasVisibilityConditions) {\n      shouldBeVisible = true;\n    }\n\n    if (element.visibleConditionsType === 'any') {\n      for (const condition of element.visibleConditions) {\n        const isSatisfied = condition.isSatisfied(record, values, cache);\n\n        if (isSatisfied) {\n          shouldBeVisible = true;\n          break;\n        }\n      }\n    } else if (element.visibleConditionsType === 'all') {\n      shouldBeVisible = true;\n\n      for (const condition of element.visibleConditions) {\n        const isSatisfied = condition.isSatisfied(record, values, cache);\n\n        if (!isSatisfied) {\n          shouldBeVisible = false;\n        }\n      }\n    }\n\n    // Make sure all parent elements are also visible according to these same rules.\n    // If a section is hidden because of a rule, all child elements are implicitly hidden\n    // and should return NO from this method. This makes it very easy to determine value relevance\n    // by looking at only the field values without having to worry about Section elements and\n    // dependencies. See clearInvisibleValuesWithConditionValues for usage of this method that\n    // relies on this behavior.\n\n    let parentsVisible = true;\n\n    let iterator = element.parent;\n\n    while (iterator != null) {\n      const parentVisible = Condition.shouldElementBeVisibleRecursive(iterator, record, values, cache);\n\n      if (!parentVisible) {\n        parentsVisible = false;\n        break;\n      }\n\n      iterator = iterator.parent;\n    }\n\n    const result = parentsVisible && shouldBeVisible;\n\n    cache[element.key] = result;\n\n    return result;\n  }\n\n  static shouldElementBeRequired(element, record, values) {\n    if (!element.hasRequiredConditions) {\n      return element.isRequired;\n    }\n\n    const cache = {};\n\n    let shouldBeRequired = false;\n\n    if (element.requiredConditionsType === 'any') {\n      for (const condition of element.requiredConditions) {\n        const isSatisfied = condition.isSatisfied(record, values, cache);\n\n        if (isSatisfied) {\n          shouldBeRequired = true;\n          break;\n        }\n      }\n    } else if (element.requiredConditionsType === 'all') {\n      shouldBeRequired = true;\n\n      for (const condition of element.requiredConditions) {\n        const isSatisfied = condition.isSatisfied(record, values, cache);\n\n        if (!isSatisfied) {\n          shouldBeRequired = false;\n          break;\n        }\n      }\n    }\n\n    return shouldBeRequired;\n  }\n\n  static valueForCondition(condition, values, record) {\n    if (condition.fieldKey === '@status') {\n      return record.statusValue;\n    }\n    return values.get(condition.fieldKey);\n  }\n\n  static elementForCondition(condition, record) {\n    if (condition.fieldKey === '@status') {\n      return record.statusValue.element;\n    }\n    return record.form.elementsByKey[condition.fieldKey];\n  }\n\n  isSatisfied(record, values, cache) {\n    const referencedElement = Condition.elementForCondition(this, record);\n\n    let isReferencedFieldSatisfied = true;\n\n    if (referencedElement != null) {\n      // If the referenced element or one its parents is explicitly marked as hidden, it's a special\n      // case and the referenced element should always be considered satisfied so that it's possible\n      // to put conditions on explicitly hidden values.\n\n      const skipElement = referencedElement.isHidden || referencedElement.hasHiddenParent;\n\n      if (!skipElement) {\n        isReferencedFieldSatisfied = Condition.shouldElementBeVisibleRecursive(referencedElement, record, values, cache);\n      }\n    }\n\n    return this._isSatisfied(record, values, isReferencedFieldSatisfied);\n  }\n\n  _isSatisfied(record, values, isReferencedFieldSatisfied) {\n    let formValue = null;\n\n    // if all of this field's conditions aren't also satisfied, treat the value as nil (empty). This has the same\n    // effect as 'clearing' invisible values by treating them as blank when their conditions aren't met, regardless\n    // of the actual preserved value in the field. If a field is invisible, its value is always nil with respect\n    // to condition logic.\n\n    if (isReferencedFieldSatisfied) {\n      formValue = Condition.valueForCondition(this, values, record);\n    }\n\n    switch (this.operator) {\n      case 'equal_to':\n        return Condition.isEqual(formValue, this.value);\n\n      case 'not_equal_to':\n        return !Condition.isEqual(formValue, this.value);\n\n      case 'is_empty':\n        return Condition.isEmpty(formValue);\n\n      case 'is_not_empty':\n        return !Condition.isEmpty(formValue);\n\n      case 'contains':\n        return Condition.contains(formValue, this.value);\n\n      case 'starts_with':\n        return Condition.startsWith(formValue, this.value);\n\n      case 'greater_than':\n        return Condition.isGreaterThan(formValue, this.value);\n\n      case 'less_than':\n        return Condition.isLessThan(formValue, this.value);\n\n      default:\n        break;\n    }\n\n    return true;\n  }\n}\n"]}