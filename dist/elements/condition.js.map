{"version":3,"sources":["../../src/elements/condition.js"],"names":[],"mappings":"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","file":"condition.js","sourcesContent":["import TextUtils from '../utils/text-utils';\n\nexport default class Condition {\n  constructor(element, attributes) {\n    this.element = element;\n    this.fieldKey = attributes.field_key;\n    this.operator = attributes.operator;\n    this.value = attributes.value;\n  }\n\n  static isEqual(formValue, stringValue) {\n    if (formValue == null) {\n      return TextUtils.isEmpty(stringValue);\n    }\n    return formValue.isEqual(stringValue);\n  }\n\n  static isEmpty(formValue) {\n    return formValue === null || formValue.isEmpty();\n  }\n\n  static contains(formValue, stringValue) {\n    if (formValue == null) {\n      return TextUtils.isEmpty(stringValue);\n    }\n    return formValue.contains(stringValue);\n  }\n\n  static startsWith(formValue, stringValue) {\n    if (formValue == null) {\n      return TextUtils.isEmpty(stringValue);\n    }\n    return formValue.startsWith(stringValue);\n  }\n\n  static isLessThan(formValue, stringValue) {\n    if (formValue == null) {\n      return TextUtils.isEmpty(stringValue);\n    }\n    return formValue.isLessThan(stringValue);\n  }\n\n  static isGreaterThan(formValue, stringValue) {\n    if (formValue == null) {\n      return TextUtils.isEmpty(stringValue);\n    }\n    return formValue.isGreaterThan(stringValue);\n  }\n\n  static shouldElementBeVisible(element, record, values, cache) {\n    if (cache != null && cache[element.key] != null) {\n      return cache[element.key];\n    }\n\n    cache = cache || {};\n\n    let shouldBeVisible = Condition.shouldElementBeVisibleRecursive(element, record, values, cache);\n\n    if (element.isSectionElement) {\n      let hasVisibleChildren = false;\n\n      for (let childElement of element.elements) {\n        const visible = Condition.shouldElementBeVisibleRecursive(childElement, record, values, cache);\n\n        if (visible) {\n          hasVisibleChildren = true;\n          break;\n        }\n      }\n\n      shouldBeVisible = shouldBeVisible && hasVisibleChildren;\n    }\n\n    return shouldBeVisible;\n  }\n\n  static shouldElementBeVisibleRecursive(element, record, values, cache) {\n    if (cache != null && cache[element.key] != null) {\n      return cache[element.key];\n    }\n\n    // break circular conditions by assigning an early `true` value so if this\n    // method is re-entered again for the same element before the recursion\n    // ends, it early exits instead of blowing the stack\n    cache[element.key] = true;\n\n    if (element.hidden || element.hasHiddenParent) {\n      cache[element.key] = false;\n      return false;\n    }\n\n    let shouldBeVisible = false;\n\n    if (!element.hasVisibilityConditions) {\n      shouldBeVisible = true;\n    }\n\n    if (element.visibleConditionsType === 'any') {\n      for (let condition of element.visibleConditions) {\n        const isSatisfied = condition.isSatisfied(record, values, cache);\n\n        if (isSatisfied) {\n          shouldBeVisible = true;\n          break;\n        }\n      }\n    } else if (element.visibleConditionsType === 'all') {\n      shouldBeVisible = true;\n\n      for (let condition of element.visibleConditions) {\n        const isSatisfied = condition.isSatisfied(record, values, cache);\n\n        if (!isSatisfied) {\n          shouldBeVisible = false;\n        }\n      }\n    }\n\n    // Make sure all parent elements are also visible according to these same rules.\n    // If a section is hidden because of a rule, all child elements are implicitly hidden\n    // and should return NO from this method. This makes it very easy to determine value relevance\n    // by looking at only the field values without having to worry about Section elements and\n    // dependencies. See clearInvisibleValuesWithConditionValues for usage of this method that\n    // relies on this behavior.\n\n    let parentsVisible = true;\n\n    let iterator = element.parent;\n\n    while (iterator != null) {\n      const parentVisible = Condition.shouldElementBeVisibleRecursive(iterator, record, values, cache);\n\n      if (!parentVisible) {\n        parentsVisible = false;\n        break;\n      }\n\n      iterator = iterator.parent;\n    }\n\n    const result = parentsVisible && shouldBeVisible;\n\n    cache[element.key] = result;\n\n    return result;\n  }\n\n  static shouldElementBeRequired(element, record, values) {\n    if (!element.hasRequiredConditions) {\n      return element.required;\n    }\n\n    const cache = {};\n\n    let shouldBeRequired = false;\n\n    if (element.requiredConditionsType === 'any') {\n      for (let condition of element.requiredConditions) {\n        const isSatisfied = condition.isSatisfied(record, values, cache);\n\n        if (isSatisfied) {\n          shouldBeRequired = true;\n          break;\n        }\n      }\n    } else if (element.requiredConditionsType === 'all') {\n      shouldBeRequired = true;\n\n      for (let condition of element.requiredConditions) {\n        const isSatisfied = condition.isSatisfied(record, values, cache);\n\n        if (!isSatisfied) {\n          shouldBeRequired = false;\n          break;\n        }\n      }\n    }\n\n    return shouldBeRequired;\n  }\n\n  static valueForCondition(condition, values, record) {\n    if (condition.fieldKey === '@status') {\n      return record.statusValue();\n    }\n    return values.get(condition.fieldKey);\n  }\n\n  static elementForCondition(condition, record) {\n    if (condition.fieldKey === '@status') {\n      return record.statusValue().statusElement;\n    }\n    return record.form.elementsByKey[condition.fieldKey];\n  }\n\n  isSatisfied(record, values, cache) {\n    const referencedElement = Condition.elementForCondition(this, record);\n\n    let isReferencedFieldSatisfied = true;\n\n    if (referencedElement != null) {\n      // If the referenced element or one its parents is explicitly marked as hidden, it's a special\n      // case and the referenced element should always be considered satisfied so that it's possible\n      // to put conditions on explicitly hidden values.\n\n      const skipElement = referencedElement.hidden || referencedElement.hasHiddenParent;\n\n      if (!skipElement) {\n        isReferencedFieldSatisfied = Condition.shouldElementBeVisibleRecursive(referencedElement, record, values, cache);\n      }\n    }\n\n    return this._isSatisfied(record, values, isReferencedFieldSatisfied);\n  }\n\n  _isSatisfied(record, values, isReferencedFieldSatisfied) {\n    let formValue = null;\n\n    // if all of this field's conditions aren't also satisfied, treat the value as nil (empty). This has the same\n    // effect as 'clearing' invisible values by treating them as blank when their conditions aren't met, regardless\n    // of the actual preserved value in the field. If a field is invisible, its value is always nil with respect\n    // to condition logic.\n\n    if (isReferencedFieldSatisfied) {\n      formValue = Condition.valueForCondition(this, values, record);\n    }\n\n    switch (this.operator) {\n      case 'equal_to':\n        return Condition.isEqual(formValue, this.value);\n\n      case 'not_equal_to':\n        return !Condition.isEqual(formValue, this.value);\n\n      case 'is_empty':\n        return Condition.isEmpty(formValue);\n\n      case 'is_not_empty':\n        return !Condition.isEmpty(formValue);\n\n      case 'contains':\n        return Condition.contains(formValue, this.value);\n\n      case 'starts_with':\n        return Condition.startsWith(formValue, this.value);\n\n      case 'greater_than':\n        return Condition.greaterThan(formValue, this.value);\n\n      case 'less_than':\n        return Condition.lessThan(formValue, this.value);\n\n      default:\n        break;\n    }\n\n    return true;\n  }\n}\n"]}